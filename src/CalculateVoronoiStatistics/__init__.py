##### Calculate Voronoi statistics #####
#
# This modifier function generates a histogram of the Voronoi motifs generated by the 
# [Voronoi analysis modifier](manual:modifiers.voronoi_analysis) sorted by occurence.

from ovito.data import DataCollection, DataTable, ElementType
from ovito.pipeline import ModifierInterface
import numpy as np
from traits.api import Enum, Int, Bool

class CalculateVoronoiStatistics(ModifierInterface):

    max_indices = Int(10, label="Show N most frequent motifs") 

    y_axis_format = Enum("Absolute", "Relative", label = "y-axis format")
    x_axis_labels = Bool(True, label="Truncate x-axis labels")
    n_start = Int(3, label = "Min Voronoi order")
    n_end = Int(6, label = "Max Voronoi order")
    use_selected = Bool(default_value=False, label= "Use only selected atoms")

    def voro_format(self, voro_index, i_start, i_end):
        s = "⟨"
        for el in voro_index[i_start-1:i_end-1]:
            s += f"{el}, "
        s += f"{voro_index[i_end-1]}⟩"    
        return s
        
    def voro_format_label(self, i_start, i_end):
        s = "⟨"
        for i in range(i_start, i_end):
            s += f"n{i}, "
        s += f"n{i_end}⟩"    
        return s                
            
    def row_histogram(self, a):
        ca = np.ascontiguousarray(a).view([('', a.dtype)] * a.shape[1])
        unique, indices, inverse = np.unique(ca, return_index=True, return_inverse=True)
        counts = np.bincount(inverse)
        sort_indices = np.argsort(counts)[::-1]
        return (a[indices[sort_indices]], counts[sort_indices])

    def modify(self, data: DataCollection, frame: int, **kwargs):

        if "Voronoi Index" not in data.particles:
            raise RuntimeError("Please generate Voronoi Indices first. \n 1) Add a Voronoi Analysis Modifier to your pipeline. \n 2) Activate the option Compute Voronoi indices.")

        if self.x_axis_labels:
            if self.n_start < 1:
                raise RuntimeError("Min. Voronoi order must be >= 1.")
            if self.n_end < self.n_start:
                raise RuntimeError("Max. Voronoi order must be >= min. Voronoi order.")
            if self.n_end > data.attributes["Voronoi.max_face_order"]:       
                print(f"Max face order is {data.attributes['Voronoi.max_face_order']}. \n"  
                    + f"Using {data.attributes['Voronoi.max_face_order']} as n_max in labels instead of {self.n_end}.")
                self.n_end = data.attributes["Voronoi.max_face_order"]
        
        if self.use_selected:
            if "Selection" not in data.particles:
                raise RuntimeError("The operation requires an input particles selection.")
            voro_indices = data.particles['Voronoi Index'][data.particles.selection == 1]
        else:
            voro_indices = data.particles['Voronoi Index']


        # Compute frequency histogram.
        unique_indices, counts = self.row_histogram(voro_indices)
        print(f"There are {len(unique_indices)} unique motifs in this dataset.")

        if self.max_indices > len(unique_indices):
            self.max_indices = len(unique_indices)
        
        table = DataTable(title=f'Voronoi statistics of the {self.max_indices} most frequent motifs', identifier='voronoi-stats', plot_mode=DataTable.PlotMode.BarChart)
        
        if self.x_axis_labels:
            table.x = table.create_property(f'Voronoi index {self.voro_format_label(self.n_start, self.n_end)}', data=np.arange(0, self.max_indices, 1, dtype=int))
            for i in np.arange(0, self.max_indices, 1, dtype=int):
                table.x.types.append(ElementType(id=i, name=self.voro_format(unique_indices[i], self.n_start, self.n_end)))
        else:
            table.x = table.create_property(f'Voronoi index {self.voro_format_label(1, data.attributes["Voronoi.max_face_order"])}', data=np.arange(0, self.max_indices, 1, dtype=int))
            for i in np.arange(0, self.max_indices, 1, dtype=int):
                table.x.types.append(ElementType(id=i, name=self.voro_format(unique_indices[i], 1, len(unique_indices[i]))))

        if self.y_axis_format == "Relative":
            table.y = table.create_property('Frequency in %', data=counts[:self.max_indices]/len(voro_indices)*100, dtype=float)
        else:
            table.y = table.create_property('Count', data=counts[:self.max_indices])
        data.objects.append(table)
        
